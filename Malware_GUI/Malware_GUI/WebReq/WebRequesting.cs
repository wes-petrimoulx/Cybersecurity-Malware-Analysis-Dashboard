using System.Net;
using System.Collections.Specialized;
using System.Security.Cryptography.X509Certificates;
using System.IO;
using System.Text;

/// <summary>
/// This will take the place of the python code for getting the json requests
/// 
/// some questions I have about how we want to structure everything:
///     1. should this class just handle the requests, and write the resonce to a file, 
///             or should it also handle the parsing through the data to find key elements that we want
///     2. If we want parsing here, that would be fine, we can just have the DataLayout class make 
///             calls to this class to get data, and COMPLETLY eleminate all file issues, keeping 
///             the scope of this class to the file, and no other class can see the file, or care about 
///             where the file is.  Parsing else where might run into tracking down where the file is issues
///             though not as bad as with the Python code.  It's just a structural thing, how we want to 
///             interact with the data.  
///     3. This isn't tested, and I'm not sure exactly how this works, but from what I gather, the layout should 
///             at least be similar enough to the python version that we can make sure the datas in the right spots.  
///     4. The User File report should be similar to the hashFileReport, but we will need to collect that file, and
///             send it off with the request.  
///     
/// I will for the time being put the JSON parsing template in here, though without seeing how the data is actually layed 
///     out, what the JSON has, I will need to refine the parsing, but having more data avalible will be benificial I think, 
///     It will give us the opertunity to expand the scope of data we are displaying to the user, and possibly make it user
///     definable, this would be tricky, but restructuring the "DataLayout" to just be 'x' number of var's and let the user
///     define what values get displayed, and how many of them might be a really useful and powerful aspect of the app.  
///     
/// USE:
///     There will need to be a class instance of this in the dataCollection class, that will call this when the button is pressed,
///     and will pass along the value from the search bar
///     The class will then do it's work and write the Json to a file. 
///     the class can then send a "flag" back for a good request on sucess, or a bad "flag" on fail
///     
///     The DataCollection class can then either (see above for structureal issues) call this class to get what data it needs to create
///         a new datalayout, or have the path returned to the DataCollection class, and do the parsing from there.  
///         
///     Once the DataCollections creates a new DataLayout, it add's it to its list, and then sends that dataLayout to the MainWindow.xaml.cs to
///         create a new element on the display for the user.  
///     
/// </summary>




public class Requesting 
{
    public Requesting()
    {


    }
        public string HashFileReport(string r)
        {
            using (var wb = new WebClient())
            {   
                //this is for the parameters for the URL
                var data = new NameValueCollection();
                data["aipkey"] = "006da2c55d12a0a9748e7038ca83fef06fc390070027a054a121bc78fff8d5a4";
                data["resource"] = r;

                //this sends the request to the server 
                var response = wb.UploadValues("https://www.virustotal.com/vtapi/v2/file/report", "GET", data);

                //this gets the responce from the server using the above post request
                return Encoding.UTF8.GetString(response);
            }
        }


        public string UserFileReport(string s)
        {
            //similar functionality for the hash report  


        }

        //this takes the whole json file from the request and writes it to a file.  
        //this file path can be modified in the future, and if there's any issues with finding the file, 
        //this can be modified to return the path to the given file.  
        public void WriteJsonToFile(string hash)
        {
            string request = HashFileReport(hash);
            var path = Path.Combine(Directory.GetCurrentDirectory(), "Json.txt");
            using (StreamWriter sw = File.CreateText(path))
            {
            //should write the hashFileReport to the given file path that was established
                sw.Write(HashFileReport(hash));
            
            }//dont need to close the stream, it closes after scope of using statement.  

            //uncomment if getting access to the file becomes an issue
            //return path;
        }


       

       
        
    }

